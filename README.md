TFLP : Functional List Processor (TFLP)
이명) The Functional List Processor

# 기계어

## 명령 분석

제 1 비트 : 코드 주소 인지
제 2 비트 : 함수 시작 인지

## 제 2 비트 거짓일시

"stack인척하는 list의".pop(argv) -> "stack인척하는 list의".push(in a top)

NOTE : 단순히 메모리 편집이다, "평범하지 않지만 합리적인 명령이지" 할정도다.

## 제 2 비트 참일시

"stack인척하는 list의".pop(argv) -> 함수호출 스택으로 ㄱㄱ

NOTE : 단순히 POP이다, "평범하지 않지만 합리적인 명령이지" 할정도다.

## 함수 호출 기전

함수 호출 스택에 주소가 푸쉬되는 즉시 다음 동작이 일어남 : 
top of stack과 program counter를 swap

NOTE : 단순히 MOV다.
NOTE : 콜스텍 복귀는 알아서 최적화되어야만 한다.

## 언어 작동 원리

베이스 포인터 기준 주소를 주소로 작동한다.

## 함수 호출 스택

제 0 깊이 : 함수 호출 레지스터
제 n 깊이 : 스택 깊이 값

## 베이스 포인터 스택

제 0 깊이 : 레지스터
제 n 깊이 : 스택

근데 사실상 -n으로 표기해서 작동함,
-2ⁿ는 예약이고, 그게 레지스터임.

## 실제 -2ⁿ에 있는 값

중간에 11이나 00으로 나오면 그러기 전의 비트를 비트수로 하여 처리하게 만듬.

## 리스트 구조

[베이스 포인터 기준 음수부 : 스택][베이스 포인터 기준 양수부 : 코드]

# 어셈블리

## 기계어 영역에서 힙과 스택영역이 아닌 const, bss, static영역 (코드 마지막에 써놓아야만 한다. 심지어 순서도 정해져있다. 아래처럼.)

주의 : 값 지정은 하드코딩이다. 하드코딩 disable옵션이 있어야 disable된다.

### `#const:` 레이블

기계어 수준에서 아주 잘 작동 (명령어 이전 체크)

### `#data:` 레이블

static 영역이다.
메모리 아낄려고 만든거라,
어셈블리보다 높은 프로그래밍용 언어에서는,
함수형 처리 최적화용으로 권장된다.

### `#bss:`

bss 영역이다.
메모리 아낄려고 만든거라,
어셈블리보다 높은 프로그래밍용 언어에서는,
함수형 처리 최적화용으로 권장된다.

## 하드코딩 비활성화

 - const & static : `변수명: 값`
 - bss : `변수명: 메모리 길이`

## 기본값

탭 두번치고 값 적기.......
음수는 마이너스 치고 꼭 적어야한다...

## 레이블 기능 활성화시 (이제 스택 주소는 양수처리)

"\t\t" 이면 레이블 없음.
"레이블명:\t" 이면 레이블 있음.